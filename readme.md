PID仿真工具
======
pid仿真工具是一个1维控制仿真软件  
# 功能  
PID仿真工具提供任意控制算法仿真、任意模型仿真功能。通过GUI显示仿真数据。软件分为2部分功能：<br/>
1、控制算法仿真<br/>
2、系统模型辨识<br/>
与MATLAB不同的是，软件可实现C代码仿真，使仿真运行的代码与实际完全一致，增加仿真可信度。<br/>
其中，控制算法仿真部分可实现任意输入源（文本文件输入）；算法变量及结果曲线绘制；实现控制参数的设置功能；提供激励数据输入接口；仿真噪声生成；仿真结果导入导出；提供一般控制效果评价；提供仿真噪声生成<br/>
未来可能扩展的功能：参数自整定<br/>
## 控制仿真操作流程  
软件总体界面：  
![](C:\cur\s11pid\pics\ui0.jpg)  
执行控制算法仿真，首先在界面*仿真*部分选择待仿真的系统模型，然后选择仿真的控制算法，这些都是在配置文件中描述好的。  
在期望数据文件编辑框内，输入文本文件名，文件内容为输入激励，输入文件格式为，多行文本，每一行一个数字，代表一个输入激励。程序自带一个阶跃响应激励，幅度50，长度为70  
设置仿真参数，可以通过*控制参数*部分，设置当前算法的控制参数；通过*噪声*部分，选择仿真过程中加入的噪声；点击**开始仿真**按钮执行仿真。  
*噪声*部分分为两种噪声，通过选择框勾选。一种是正态分布噪声，可以输入均值和方差，噪声直接加在系统模型输出上；另一种是正太分布的累积型噪声，可以输入均方差，每次随机噪声累加后，加载系统模型输出上。  
仿真结束后，仿真数据将按配置文件的描述，输出误差曲线e，控制器输出u，和其他算法模块自定义的变量曲线。在*效果评估*部分，可以查看控制结果相对期望值的误差情况，有均方误差和最大偏离值两个指标。**跳过值**表示在效果评估时，跳过最开始期望变化带来的直接误差。  
曲线显示时，可能由于误差e与系统输出u的量纲不同，e的数值范围一般较小，导致曲线上很难同时看清e和u。可以通过*误差曲线放大*来设置e的显示系数，让e的曲线放大(或缩小)后，与控制器输出显示在同一曲线图中。  
曲线图中，右键单击图表，可缩小曲线；左键框选曲线，可放大框选范围；点击*适应屏幕*按钮，可恢复曲线的完整显示。  
仿真结束后，可点击*保存数据*将曲线数据保存到CSV文件，也可在任何时候点击*导入数据*按钮，将之前存储的曲线数据加载到软件中显示。  
## 系统辨识操作流程  
要执行系统辨识，首先要收集系统的输入、输出数据，保存成CSV格式。文件内容为2列，第一列为系统输入，第2列为系统输出。选择要辨识的模型，点击*辨识*按钮后，软件弹出文件选择对话框，选择系统数据。然后软件将数据提供给模型算法，调用其辨识接口，实现系统辨识。结束后，软件显示辨识的准确度，并询问是否保存。辨识后的模型以模型配置文件的形式存储在exe目录下的模型目录(model)  
若所选的模型算法没有提供辨识接口，则弹出提示，停止执行。  
# 程序结构  
QT应用程序，启动时加载exe目录下的model目录下的模型配置文件，和Ctrl目录下的控制算法配置文件。所有可选择的算法和模型都以配置文件的形式存在，一个配置文件描述一个算法或模型，多个配置文件描述的算法或模型可以是同一个动态库里的函数。动态库存放在lib文件夹中  
```
├── ctrl				控制算法目录
│   └── basepid.ctrljson	控制算法文件为*.ctrljson
├── lib					动态库目录
│   └── baseso.so
└── model				模型目录
    └── arma.mdjson			控制算法文件为*.mdjson
```
主程序加载所有的**系统模型**和**控制算法**后，用户可在列表中选择要仿真的算法和模型，进行仿真。仿真时，主程序将配置文件中的配置参数发送给动态库的函数，并加载输入激励，执行仿真。  
所以，主程序仅实现仿真流程，而控制算法和系统模型都由外部实现，从而实现算法的扩展。  
## 扩展接口
主程序调用动态库中的函数定义：  
1. 算法函数：float ctrl_fun_basepid(float exp,float y);
	输入：期望值exp，和系统的当前值y，返回控制算法的输出
1. 模型函数：float model_fun_arma(float u);  
	输入：系统激励u(控制器输出)，输出系统模型输出  
1. 辨识函数：float rec_fun_arma(float *u,float *y,int n);  
	输入：系统激励列表u，系统模型输出列表y，列表长度n，输出辨识信度
	辨识函数与模型函数必须在同一动态库中  
	运行后，直接改变动态库中模型函数的参数，调用者通过配置函数读出  
1. 配置函数：const char *cmd_fun(const char *s);  
	输入json字符串，输出结果字符串  
	控制算法和系统模型都需要通过配置函数进行参数配置和读出  

其中，一个控制算法需要实现**算法函数**，**配置函数**  
一个系统模型需要实现**模型函数**，**配置函数**，若有针对此模型的辨识算法，还可实现**辨识函数**  
软件已经实现了一个基础的模型和基础的pid算法。所有代码都编写在**baseso.so**中，控制算法名为**basepid.ctrljson**，模型名称为**arma.mdjson**  
配置函数的约定：主程序通过配置函数对动态库扩展的算法进行控制，指令如下：  
|命令|类型|含义|案例|
|-----|-----|-----|-----|
|控制算法函数名|string|设置控制算法状态|{"ctrl_fun_basepid":"ini"}|
|系统模型函数名|string|设置系统模型状态|{"model_fun_arma":"get_cfg"}|
|cfg|object|若指令是set_cfg,则这个对象是cfg|{"model_fun_arma":"set_cfg","cfg": { "A_list":[0.2], "B_list":[0,0.8] }}|
其中，控制算法的指令包括：  
|命令|含义|
|-----|-----|
|ini|初始化算法的状态，用于开始新的仿真，防止残留之前的状态|
|set_cfg|设置参数|
|get_cfg|获取当前参数，其中，可以包含curve域，curve是个数组，每个项是一个曲线的名称。数组长度需要与每次仿真给出的要画曲线的参数数量一致|
|curve|每个仿真周期调用的，获取待绘制曲线参数的指令，返回curve域，curve是个数组，这里数组的每一项是double型，表示每个参数|
对于系统模型的指令，仅有其中的set_cfg和get_cfg，且含义相同。  
## 系统模型部分  
系统模型配置文件结构：
```json
{
	"dllname":"baseso.so",
	"funname":"model_fun_arma",
	"recname":"rec_fun_arma",
	"cfg": { "A_list":[0.2], "B_list":[0,0.8] }
}
```
其中描述了此系统模型的函数位置，位于"dllname"中，系统模型函数名为"funname"，辨识算法函数名为"recname"，模型的参数为"cfg"。其中"cfg"域的内容是模型算法自定义的，主程序读取cfg的内容后，在每次运行时，通过配置函数传递给算法。  
## 控制算法部分  
控制算法配置文件结构：  
```json
{
	"dllname":"baseso.so",
	"funname":"ctrl_fun_basepid",
	"cfgdes":
	[
		{"name":"k_in","dft":0.5,"type":"double","des":""},
		{"name":"P","dft":10,"type":"double","des":""},
		………………………………
	]
}
```
其中，控制算法函数在"dllname"的动态库中，控制算法函数名为"funname"，控制算法的参数描述为"cfgdes"。cfgdes为一个描述对象列表，列表中的每个元素为一个参数，其中name为参数名，dft为参数默认值，type为参数类型，类型有double、int、string、obj、array几种。des为参数的描述  
cfgdes中的参数会被显示在界面上，在仿真前，可进行调整。以实现参数整定。  
# 主程序  
## 代码组织  
主程序的可复用代码放在common文件夹中。界面和操作逻辑在mainwindow模块中，业务流程在appflow模块中，显示json配置：dictdis.h，帮助页面：help.html  
main.cpp实现程序的启动流程，加载算法和系统模型配置，并调用初始化函数建立数据结构。  
appflow模块中定义了CAlgObj(程序对象)，使用程序对象组织控制算法和系统模型。  
程序对象定义了json操作toJson和fromJson，用于和配置文件交互。  
在对象中定义了函数指针，在初始化阶段将动态库中的函数加载，在对象中保存其函数指针，待仿真流程时使用。  
仿真函数为：**sim_proc**，在appflow.cpp中定义。函数中使用回调函数实现曲线的调用  
# 编写控制算法/模型的案例  
要编写一个算法共仿真软件使用，首先需要建立动态链接库工程，建立**扩展接口**中描述的相关函数，函数调用规则为cdecl，命名规则为C(C++程序需使用extern "C")  
然后需要实现cmd_fun，作为主程序和动态库交互的接口，使用json字符进行交互，具体实现详见代码  
