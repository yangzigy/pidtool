PID仿真工具
======
pid仿真工具是一个1维控制仿真软件  
# 功能  
PID仿真工具提供任意控制算法仿真、任意模型仿真功能。通过GUI显示仿真数据。软件分为2部分功能：<br/>
1、控制算法仿真<br/>
2、系统模型辨识<br/>
与MATLAB不同的是，软件可实现C代码仿真，使仿真运行的代码与实际完全一致，增加仿真可信度。<br/>
其中，控制算法仿真部分可实现任意输入源（文本文件输入）；算法变量及结果曲线绘制；实现控制参数的设置功能；提供激励数据输入接口；仿真噪声生成；仿真结果导入导出；提供一般控制效果评价；提供仿真噪声生成<br/>
未来可能扩展的功能：参数自整定<br/>
# 结构  
QT应用程序，启动时加载exe目录下的model目录下的模型配置文件，和Ctrl目录下的控制算法配置文件。所有可选择的算法和模型都以配置文件的形式存在，一个配置文件描述一个算法或模型，多个配置文件描述的算法或模型可以是同一个动态库里的函数。动态库存放在lib文件夹中  
```
├── ctrl				控制算法目录
│   └── basepid.ctrljson	控制算法文件为*.ctrljson
├── lib					动态库目录
│   └── baseso.so
└── model				模型目录
    └── arma.mdjson			控制算法文件为*.mdjson
```
主程序加载所有的**系统模型**和**控制算法**后，用户可在列表中选择要仿真的算法和模型，进行仿真。仿真时，主程序将配置文件中的配置参数发送给动态库的函数，并加载输入激励，执行仿真。  
所以，主程序仅实现仿真流程，而控制算法和系统模型都由外部实现，从而实现算法的扩展。  
## 扩展接口
主程序调用动态库中的函数定义：  
1. 算法函数：float ctrl_fun_basepid(float exp,float y);
	输入：期望值exp，和系统的当前值y，返回控制算法的输出
1. 模型函数：float model_fun_arma(float u);  
	输入：系统激励u(控制器输出)，输出系统模型输出  
1. 辨识函数：float rec_fun_arma(float *u,float *y,int n);  
	输入：系统激励列表u，系统模型输出列表y，列表长度n，输出辨识信度
	辨识函数与模型函数必须在同一动态库中  
	运行后，直接改变动态库中模型函数的参数，调用者通过配置函数读出  
1. 配置函数：const char *cmd_fun(const char *s);  
	输入json字符串，输出结果字符串  
	控制算法和系统模型都需要通过配置函数进行参数配置和读出  

其中，一个控制算法需要实现**算法函数**，**配置函数**  
一个系统模型需要实现**模型函数**，**配置函数**，若有针对此模型的辨识算法，还可实现**辨识函数**  
软件已经实现了一个基础的模型和基础的pid算法。所有代码都编写在**baseso.so**中，控制算法名为**basepid.ctrljson**，模型名称为**arma.mdjson**  
配置函数的约定：主程序通过配置函数对动态库扩展的算法进行控制，指令如下：  
|命令|类型|含义|案例|
|-----|-----|-----|-----|
|控制算法函数名|string|设置控制算法状态|{"ctrl_fun_basepid":"ini"}|
|系统模型函数名|string|设置系统模型状态|{"model_fun_arma":"get_cfg"}|
|cfg|object|若指令是set_cfg,则这个对象是cfg|{"model_fun_arma":"set_cfg","cfg": { "A_list":[0.2], "B_list":[0,0.8] }}|
其中，控制算法的指令包括：  
|命令|含义|
|-----|-----|
|ini|初始化算法的状态，用于开始新的仿真，防止残留之前的状态|
|set_cfg|设置参数|
|get_cfg|获取当前参数，其中，可以包含curve域，curve是个数组，每个项是一个曲线的名称。数组长度需要与每次仿真给出的要画曲线的参数数量一致|
|curve|每个仿真周期调用的，获取待绘制曲线参数的指令，返回curve域，curve是个数组，这里数组的每一项是double型，表示每个参数|
对于系统模型的指令，仅有其中的set_cfg和get_cfg，且含义相同。  
## 系统模型部分  
系统模型配置文件结构：
```json
{
	"dllname":"baseso.so",
	"funname":"model_fun_arma",
	"recname":"rec_fun_arma",
	"cfg": { "A_list":[0.2], "B_list":[0,0.8] }
}
```
其中描述了此系统模型的函数位置，位于"dllname"中，系统模型函数名为"funname"，辨识算法函数名为"recname"，模型的参数为"cfg"。其中"cfg"域的内容是模型算法自定义的，主程序读取cfg的内容后，在每次运行时，通过配置函数传递给算法。  
## 控制算法部分  
控制算法配置文件结构：  
```json
{
	"dllname":"baseso.so",
	"funname":"ctrl_fun_basepid",
	"cfgdes":
	[
		{"name":"k_in","dft":0.5,"type":"double","des":""},
		{"name":"P","dft":10,"type":"double","des":""},
		………………………………
	]
}
```
其中，控制算法函数在"dllname"的动态库中，控制算法函数名为"funname"，控制算法的参数描述为"cfgdes"。cfgdes为一个描述对象列表，列表中的每个元素为一个参数，其中name为参数名，dft为参数默认值，type为参数类型，类型有double、int、string、obj、array几种。des为参数的描述  
cfgdes中的参数会被显示在界面上，在仿真前，可进行调整。以实现参数整定。  
# 主程序  
## 代码组织  
主程序的可复用代码放在common文件夹中。界面和操作逻辑在mainwindow模块中，业务流程在appflow模块中，显示json配置：dictdis.h，帮助页面：help.html  
main.cpp实现程序的启动流程，加载算法和系统模型配置，并调用初始化函数建立数据结构。  
appflow模块中定义了CAlgObj(程序对象)，使用程序对象组织控制算法和系统模型。  
程序对象定义了json操作toJson和fromJson，用于和配置文件交互。  
在对象中定义了函数指针，在初始化阶段将动态库中的函数加载，在对象中保存其函数指针，待仿真流程时使用。  
仿真函数为：**sim_proc**，在appflow.cpp中定义。函数中使用回调函数实现曲线的调用  
## 曲线定义  

